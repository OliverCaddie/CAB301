\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}



\begin{document}
\setkeys{Gin}{width=1.0\textwidth}
\SweaveOpts{concordance=TRUE}



COVER PAGE

\pagebreak



\tableofcontents


\pagebreak


\section{Algorithm Description}
\subsection{Preliminary Overview}
The algorithm shown in Figure 1. searches the given array of numbers, $a$, for the "median" value: the value located at $\lceil \frac{n}{2} \rceil$ in the sorted array, $a'$. It achieves this by iterating through $a$ and counting how many elements are equal ($e$) and how many are less than ($s$) each element until it reaches one that satisfies the condition:
\begin{align*}
s < \Big\lceil \frac{n}{2} \Big\rceil \leq s + e
\end{align*}
The above inequality will be satisfied by a value, $a_i$ where there are less than $\lceil \frac{n}{2} \rceil$ values before it and the number of elements less than or equal to it are greater than or equal to $\lceil \frac{n}{2} \rceil$ in the sorted array $a'$. Thus it can only be satisfied by the value at $a_{\lceil \frac{n}{2} \rceil}'$.

\subsection{Efficiency Class}
Finding this algorithm's efficiency class provides several problems. There are two basic operations: the comparisons within the inner for-loop. One is guaranteed to be performed, the second is only performed when the first comparison evaluates false. To further compound this, the outer for-loop can prematurely exit on any iteration. A probabilistic approach seems the most applicable.

\subsubsection{Inner Loop}
An iteration of the inner loop's operation count is dependent on whether $a_i > a_j$. If we assume the numbers within the array are Uniformly distributed between bounds, $b$ and $c$:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% Eq'n for P(X<=Y)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
& Let\ X,Y \overset{i.i.d.}{\sim} Uniform(b, c) && \text{(discrete)}\\
& Where\ X,Y\ corresponds\ to\ a_i, a_j\ respectively 
\end{flalign*}
\begin{equation*}
P(X=x) = P(Y=y) = \frac{1}{m},\ m = c - b + 1
\end{equation*}
\begin{flalign*}
& Let\ W = Y - X \\
& \therefore W \sim Triangular(1-m, 0, m-1) && \text{(discrete)}
\end{flalign*}
\begin{align*}
P(W=w) &= \frac{m - w}{m^2},\ w \geq 0 \\
P(W \geq w) &= \sum_{i=w}^{m-1} \frac{m - i}{m^2} \\
P(W \geq 0) &= \frac{1}{m^2} \Bigg( \sum_{i=0}^{m-1} m - \sum_{i=0}^{m-1} i \Bigg) \\
P(W \geq 0) &= \frac{2m^2 - m(m-1)}{2m^2} \\
P(W \geq 0) &= \frac{m+1}{2m} = P(X \leq Y)
\end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Now, with the probability that the first condition will fail, the number of second basic operations performed can be modelled Binomially, with $n$ being the length of the array.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% Eq'n for Inner Loop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
& Let\ U \sim Binomial(P(X \leq Y), n-1) &&
\end{flalign*}

\begin{align*}
C_1(n) &= \sum_{i=1}^{n-1}1 + \mathbb{E}[U] + 2 \\
&= n - 1 + \frac{(n-1)(m+1)}{2m} + 2 \\
C_1(n) &= \frac{(n-1)(3m+1) + 4m}{2m} \in \Theta(n)
\end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
With that, the inner loop, defined as $C_1(n)$, can be seen to increase linearly as the problem size increases.

\subsubsection{Outer Loop}
First, we can assume that the median is equally likely to appear in any position in $a$. This is due to the fact the values in $a$ are independent and identically distributed. However, this does not lead to the conclusion the algorithm is equally likely to terminate at all positions. The algorithm begins its search at the beginning of the array. So, despite the "median" being equally likely to occur at any position, the algorithm will end on the first occurrence. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% Eq'n for Outer Loop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
& Let\ B \sim Binomial\Big(\frac{1}{m}, n-1\Big) \\
& and\ B' = B + 1
\end{flalign*}
Therefore, $B'$ is the number of median values in our array, with moment generating function:
\begin{align*}
m_{B'}(s) &= s\Big(1 + \frac{s-1}{m}\Big)^{n-1}
\end{align*}

\begin{flalign*}
& Let\ X \sim Uniform(1, n) && \text{(discrete)}
\end{flalign*}
Where $X$ is the position of a median value, with cumulative distribution function: 
\begin{align*}
F_X(x) &= P(X \leq x) = \frac{\lceil x \rceil}{n}
\end{align*}

\begin{flalign*}
& Let\ X_1, ..., X_{B'}\ \text{be a random sample on $X$} && \\
& X_{(1)}\ \text{is the first order statistic; the smallest $X_i$ sampled}
\end{flalign*}

\begin{align*}
F_{X_{(1)}}(x) &= 1 - m_{B'}\big(1-F_X(x)\big) \\
&= 1 - \bigg(1 - \frac{\lceil x \rceil}{n}\bigg)\Bigg(1 + \frac{1 - \frac{\lceil x \rceil}{n} - 1}{m}\Bigg)^{n-1} \\
&= 1 - \bigg(1 - \frac{\lceil x \rceil}{n}\bigg)\bigg(1 - \frac{\lceil x \rceil}{nm}\bigg)^{n-1} \\
\mathbb{E}[X_{(1)}] &= \sum_x (1 - F_{X_{(1)}}(x)) \\
\therefore C_2(n) &= \sum_{x=1}^n \Big(1 - \frac{x}{n}\Big)\Big(1 - \frac{x}{nm}\Big)^{n-1}
\end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Extrapolating an efficiency class for this loop is troublesome, although a possible method is discussed in the next section.


\subsubsection{Final Efficiency Class}
The final average efficiency, $C(n)$, for the algorithm is achieved below:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% Eq'n for Algorithm
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{align*}
C(n) &= C_1(n)C_2(n) \\
&= \frac{(n-1)(3m+1) + 4m}{2m} \sum_{x=1}^n \Big(1 - \frac{x}{n}\Big)\Big(1 - \frac{x}{nm}\Big)^{n-1}
\end{align*}
As previously mentioned, a helpful efficiency class is not apparent from the above formula. Though, in the limit as $m\to\infty$, one can be gleaned.
\begin{align*}
\lim_{m\to\infty}C(n) &= \frac{3n+1}{2} \sum_{x=1}^n \Big(1 - \frac{x}{n}\Big) \\
\lim_{m\to\infty}C(n) &= \frac{3n+1}{2} \cdot \frac{n-1}{2} \\
\lim_{m\to\infty}C(n) &= \frac{3n^2-2n-1}{4} \in \Theta(n^2)
\end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This makes intuitive sense, as when $m\to\infty$ the probability of multiple "medians" $\to 0$, leading to a second order efficiency.




\section{Algorithm Implementation}




\section{Methodology}
\subsection{Computing Environment}

\subsection{Experimental Design}




\section{Results}

\subsection{Basic Operation Count}

\subsection{Running Time}


\section{Analysis}






















<<loadData, echo=FALSE>>=
library(ggplot2)
library(dplyr)
df <- read.delim("D:/Documents/code/java/university/src/cab301/results.txt")

df.c <- select(df, n, count)
df.t <- select(df, n, time)

df.tc <- select(df, time, count)

c.avg <- aggregate(count ~ n, df.c, mean)
t.avg <- aggregate(time ~ n, df.t, mean)

tc.avg <- data.frame(t.avg$time, c.avg$count)
colnames(tc.avg) <- c('time', 'count')

r <- 1
m <- 2^32
factor <- 1
f.class <- function(x) x^2

c1 <- function(x) ((x-1)*(3*(x)+1))/(2*(x))+2
c2 <- function(x) {
  out <- {}
  for (i in x) {
    out <- c(out, sum((1 - (1:i)/i) * (1 - (1:i)/((i)*i))^(i-1)))
  }
  out
}
f.pred <- function(x) c1(x)*c2(x)
@
aaaaa

\begin{figure}[htbp]
<<plot1, fig=TRUE, echo=FALSE, width=7, height=5>>=
ggplot(df.c) +
  geom_point(aes(x = n, y = count, colour = 'obs'), size = 1, shape = 1) +
  geom_point(data = c.avg, aes(x = n, y = count, colour='avg'), size = 2, shape = 1) + 
  stat_function(fun = f.pred, aes(colour = 'pred'), size = 1, linetype = 1) +
  ggtitle("Operation Count on Length of Array") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 18, face = "bold"), axis.title = element_text(size = 14), legend.text = element_text(size = 14)) +
  scale_colour_manual("", values = c("obs"='#a0a0a0', "avg"='#202020', 'pred'='#000000'))
@
\end{figure}

\begin{figure}[htbp]
<<plot2, fig=TRUE, echo=FALSE, width=10, height=8>>=
library(ggplot2)
ggplot(df.t) +
  geom_point(aes(x = n,y = time, colour = 'obs'), size = 1) +
  geom_point(data=t.avg, aes(x = n,y = time, colour='avg'), size = 2) +
  ggtitle("Execution Time on Length of Array") +
  ylab("time(milliseconds)") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),
        axis.title = element_text(size = 14),
        legend.text = element_text(size = 14)) +
  scale_colour_manual("", values = c("obs"='#606060', "avg"='#2050a0'))
@
\end{figure}
aaaa


\end{document}